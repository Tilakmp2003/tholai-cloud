import { PrismaClient, Task, TaskStatus } from '@prisma/client';
import { callLLM } from '../llm/llmClient';
import { getAgentConfig } from '../llm/modelRegistry';

const prisma = new PrismaClient();

export class TeamLeadAgent {
  
  async reviewTask(task: Task, designContext: any, previousAttempts: any[]): Promise<any> {
    const isDesignTask = task.requiredRole === 'DESIGNER';

    const CODE_REVIEW_PROMPT = `
You are a Team Lead Engineer (L6). Your job is to REVIEW the work of a Developer Agent.
You are the Quality Gatekeeper. You prevent bad code from merging.

INPUT:
- Task: ${task.title}
- Design Context: ${JSON.stringify(designContext)}
- Previous Attempts: ${JSON.stringify(previousAttempts)}
- Current Output: ${task.outputArtifact || "No output"}

YOUR PROCESS:
1. Read the Design Context (ADR, Proposal). Does the code match the design?
2. Run a MENTAL PRE-REVIEW CHECKLIST:
   - API Contract: Are inputs/outputs correct?
   - Security: Any SQL injection, XSS, or auth bypass risks?
   - Performance: Any O(n^2) loops or N+1 queries?
   - Complexity: Is the code readable?
3. DECIDE:
   - "APPROVE": Code is good.
   - "REQUEST_CHANGES": Code has issues. Provide specific feedback.
   - "ESCALATE": You are unsure or the design is flawed.

OUTPUT JSON ONLY:
{
  "decision": "APPROVE" | "REQUEST_CHANGES" | "ESCALATE",
  "feedback": [
    {
      "file": "path/to/file",
      "line": 123,
      "issue": "Brief description of issue",
      "explanation": "Why this is bad",
      "patch_hint": "One-line code fix suggestion"
    }
  ],
  "audit_note": "Short summary for the audit log",
  "mentoring_tip": "Optional: A general coding tip based on the errors found"
}
`;

    const DESIGN_REVIEW_PROMPT = `
You are a Creative Director and Head of Product. Your job is to REVIEW the Design Package generated by a Designer Agent.
You are the Brand Guardian. You prevent ugly or unusable designs from proceeding.

INPUT:
- Task: ${task.title}
- Design Brief: ${JSON.stringify(task.contextPacket || {})}
- Design Package: ${task.outputArtifact || "No output"}

YOUR PROCESS:
1. Does the design meet the Design Brief goals?
2. Is the "Recommended Direction" strong and distinct?
3. Are the User Journey and Wireframes logical?
4. Is the Accessibility Report passing?
5. DECIDE:
   - "APPROVE": Design is excellent.
   - "REQUEST_CHANGES": Design needs work. Provide specific feedback.
   - "ESCALATE": Design is fundamentally flawed or brief is unclear.

OUTPUT JSON ONLY:
{
  "decision": "APPROVE" | "REQUEST_CHANGES" | "ESCALATE",
  "feedback": [
    {
      "section": "Wireframes",
      "issue": "Navigation is confusing",
      "suggestion": "Add a home button"
    }
  ],
  "audit_note": "Short summary of the review",
  "mentoring_tip": "Optional: A design tip"
}
`;

    const systemPrompt = isDesignTask ? DESIGN_REVIEW_PROMPT : CODE_REVIEW_PROMPT;

    const config = await getAgentConfig('TeamLead');
    const response = await callLLM(config, [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: "Review this task output." }
    ]);

    try {
        const cleanResponse = response.content.replace(/```json/g, '').replace(/```/g, '').trim();
        return JSON.parse(cleanResponse);
    } catch (e) {
        console.error("Failed to parse Team Lead response", e);
        return { decision: "ESCALATE", feedback: [], audit_note: "JSON Parse Error" };
    }
  }
}

export async function runTeamLeadAgentOnce() {
    // Find tasks waiting for review
    const tasksToReview = await prisma.task.findMany({
        where: { status: 'IN_REVIEW' },
        take: 5 // Process a few at a time
    });

    if (tasksToReview.length === 0) return;

    console.log(`[TeamLead] Found ${tasksToReview.length} tasks to review.`);

    const agent = new TeamLeadAgent();

    for (const task of tasksToReview) {
        console.log(`[TeamLead] Reviewing Task ${task.id}: ${task.title}`);
        
        try {
            // Fetch context (Design, History)
            const designContext = task.designContext || {};
            const history = (task.history as any[]) || [];

            const reviewResult = await agent.reviewTask(task, designContext, history);

            let newStatus: TaskStatus = task.status;
            const isDesignTask = task.requiredRole === 'DESIGNER';
            
            if (reviewResult.decision === 'APPROVE') {
                console.log(`[TeamLead] ✅ Approved Task ${task.id}`);
                newStatus = isDesignTask ? 'COMPLETED' : 'IN_QA'; // Design -> Completed, Code -> QA
            } else if (reviewResult.decision === 'REQUEST_CHANGES') {
                console.log(`[TeamLead] ❌ Requested Changes for Task ${task.id}`);
                newStatus = 'IN_PROGRESS'; // Send back to Designer/Dev
                // Note: We might want a separate status like 'NEEDS_REVISION' but IN_PROGRESS works if we re-assign
            } else if (reviewResult.decision === 'ESCALATE') {
                console.log(`[TeamLead] ⚠️ Escalated Task ${task.id}`);
                newStatus = 'WAR_ROOM'; // Or some blocked state
            }

            await prisma.task.update({
                where: { id: task.id },
                data: {
                    status: newStatus,
                    reviewDecision: reviewResult.decision,
                    reviewFeedback: reviewResult as any,
                    lastReviewBy: 'TeamLeadAgent',
                    lastReviewAt: new Date()
                } as any
            });

        } catch (error) {
            console.error(`[TeamLead] Error reviewing task ${task.id}:`, error);
        }
    }
}
