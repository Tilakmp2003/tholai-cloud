/**
 * PR Generator Service
 * 
 * Generates pull request descriptions with:
 * - Trace links
 * - Patch summary
 * - Confidence scores
 * - Test results
 * - Auto-labels
 */

import { PrismaClient } from '@prisma/client';
import { callLLM } from '../llm/llmClient';
import { ModelConfig } from '../llm/types';
import { emitLog } from '../websocket/socketServer';

const prisma = new PrismaClient();

const DEFAULT_MODEL_CONFIG: ModelConfig = {
  provider: 'gemini',
  model: 'gemini-2.0-flash',
  maxTokens: 1024,
  temperature: 0.3
};

export interface PRMetadata {
  taskId: string;
  projectId: string;
  moduleName: string;
  agentRole: string;
  confidence: number;
  filesChanged: string[];
  testsRun: number;
  testsPassed: number;
  traceId?: string;
}

export interface GeneratedPR {
  title: string;
  body: string;
  labels: string[];
  confidence: number;
  autoMergeEligible: boolean;
}

/**
 * Calculate confidence score for a patch
 */
export function calculateConfidence(metadata: PRMetadata): number {
  let confidence = 0.5; // Base confidence
  
  // Test pass rate (0-30%)
  if (metadata.testsRun > 0) {
    const passRate = metadata.testsPassed / metadata.testsRun;
    confidence += passRate * 0.3;
  }
  
  // Agent role bonus (senior agents = higher confidence)
  const roleBonus: Record<string, number> = {
    'Architect': 0.15,
    'SeniorDev': 0.12,
    'MidDev': 0.08,
    'JuniorDev': 0.05
  };
  confidence += roleBonus[metadata.agentRole] || 0.05;
  
  // File count penalty (more files = lower confidence)
  const filePenalty = Math.min(0.1, metadata.filesChanged.length * 0.02);
  confidence -= filePenalty;
  
  return Math.min(0.99, Math.max(0.1, confidence));
}

/**
 * Generate PR labels based on metadata
 */
export function generateLabels(metadata: PRMetadata, confidence: number): string[] {
  const labels: string[] = ['auto-generated', 'requires-review'];
  
  // Confidence label
  if (confidence >= 0.9) {
    labels.push('confidence:high');
  } else if (confidence >= 0.7) {
    labels.push('confidence:medium');
  } else {
    labels.push('confidence:low');
  }
  
  // Size labels
  if (metadata.filesChanged.length === 1) {
    labels.push('size:xs');
  } else if (metadata.filesChanged.length <= 3) {
    labels.push('size:s');
  } else if (metadata.filesChanged.length <= 7) {
    labels.push('size:m');
  } else {
    labels.push('size:l');
  }
  
  // Test labels
  if (metadata.testsRun > 0) {
    if (metadata.testsPassed === metadata.testsRun) {
      labels.push('tests:passing');
    } else {
      labels.push('tests:failing');
    }
  } else {
    labels.push('tests:none');
  }
  
  // Agent label
  labels.push(`agent:${metadata.agentRole.toLowerCase()}`);
  
  return labels;
}

/**
 * Generate "why this patch" explanation
 */
async function generateExplanation(
  taskTitle: string,
  filesChanged: string[],
  traceId?: string
): Promise<string> {
  try {
    const response = await callLLM(DEFAULT_MODEL_CONFIG, [
      {
        role: 'system',
        content: 'You are a technical writer. Write a 1-2 sentence explanation of why this code change was made. Be concise and specific.'
      },
      {
        role: 'user',
        content: `Task: ${taskTitle}\nFiles changed: ${filesChanged.join(', ')}\n\nExplain why this change was made in 1-2 sentences.`
      }
    ]);
    
    return response.content.trim();
  } catch (error) {
    return `Implements: ${taskTitle}`;
  }
}

/**
 * Generate full PR description
 */
export async function generatePRDescription(metadata: PRMetadata): Promise<GeneratedPR> {
  const confidence = calculateConfidence(metadata);
  const labels = generateLabels(metadata, confidence);
  const explanation = await generateExplanation(
    metadata.taskId,
    metadata.filesChanged,
    metadata.traceId
  );
  
  // Fetch task details
  const task = await prisma.task.findUnique({
    where: { id: metadata.taskId },
    include: { module: true }
  });
  
  const title = `ü§ñ ${task?.title || 'Auto-generated changes'}`;
  
  const body = `## Summary

${explanation}

## Details

| Field | Value |
|-------|-------|
| **Task ID** | \`${metadata.taskId}\` |
| **Module** | ${metadata.moduleName} |
| **Agent** | ${metadata.agentRole} |
| **Confidence** | ${(confidence * 100).toFixed(0)}% |
| **Files Changed** | ${metadata.filesChanged.length} |

## Files Changed

${metadata.filesChanged.map(f => `- \`${f}\``).join('\n')}

## Test Results

${metadata.testsRun > 0 
  ? `‚úÖ ${metadata.testsPassed}/${metadata.testsRun} tests passing`
  : '‚ö†Ô∏è No tests run'}

## Trace

${metadata.traceId 
  ? `[View execution trace](./traces/${metadata.traceId})`
  : 'No trace available'}

---

<details>
<summary>ü§ñ Auto-generated by AI Agent</summary>

This PR was automatically generated by the Virtual Software Company platform.
- **Confidence Score**: ${(confidence * 100).toFixed(0)}%
- **Auto-merge eligible**: ${confidence >= 0.9 ? 'Yes' : 'No'}

Please review carefully before merging.

</details>`;

  const autoMergeEligible = confidence >= 0.9 && 
    metadata.testsPassed === metadata.testsRun && 
    metadata.testsRun > 0;

  emitLog(`[PRGenerator] üìù Generated PR: ${title} (confidence: ${(confidence * 100).toFixed(0)}%)`);

  return {
    title,
    body,
    labels,
    confidence,
    autoMergeEligible
  };
}

/**
 * Generate PR for a completed task
 */
export async function generatePRForTask(taskId: string): Promise<GeneratedPR | null> {
  const task = await prisma.task.findUnique({
    where: { id: taskId },
    include: {
      module: {
        include: { project: true }
      },
      assignedToAgent: true
    }
  });
  
  if (!task || !task.module) {
    return null;
  }
  
  // Get files from task result
  const result = task.result as any;
  const filesChanged = result?.targetFile 
    ? [result.targetFile]
    : (task.files as any)?.map((f: any) => f.path) || [];
  
  const metadata: PRMetadata = {
    taskId: task.id,
    projectId: task.module.projectId,
    moduleName: task.module.name,
    agentRole: task.assignedToAgent?.role || 'Unknown',
    confidence: 0,
    filesChanged,
    testsRun: 0, // Would come from test results
    testsPassed: 0,
    traceId: task.traceId || undefined
  };
  
  return generatePRDescription(metadata);
}

export const prGenerator = {
  calculateConfidence,
  generateLabels,
  generatePRDescription,
  generatePRForTask
};
